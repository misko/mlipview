<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>FAIRChem UMA viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
  html,body { margin:0; padding:0; height:100%; background:#ffffff; font-family: system-ui, sans-serif; color:#222; }
    #app { position:relative; width:100%; height:100%; overflow:hidden; }
    canvas { width:100%; height:100%; display:block; }
    .hud { position:absolute; top:8px; left:8px; background:rgba(20,26,34,0.65); border:1px solid rgba(255,255,255,0.07); border-radius:8px; padding:8px 12px; font-size:13px; backdrop-filter: blur(4px); }
    .hud button { margin-right:6px; }
    .footer { position:absolute; bottom:8px; left:8px; font-size:11px; opacity:0.6; }
    a { color:#7fc4ff; }
    /* Removed standalone VR/AR buttons; unified AR transparency toggle lives in HUD */
    .hud .inline-toggle { display:inline-flex; align-items:center; gap:4px; margin-left:4px; }
  </style>
  <!-- Load Babylon globally so legacy-style modules that reference global BABYLON work -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <!-- Loaders plugin for glTF/glb (controllers, hand meshes) -->
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
  <!-- Babylon GUI for XR HUD overlay -->
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script>
    // Predeclare global so console commands entered early don't throw ReferenceError
    (function(){ try { if(typeof window!=='undefined' && !('viewerApi' in window)) window.viewerApi = null; } catch{} })();
  </script>
  <script>
    // Optional latency debug: enable with ?debugLatency=1 to log round-trip times of all fetch() calls
    (function(){
      try {
        const params = new URLSearchParams(location.search||'');
        if (params.get('debugLatency') === '1') {
          const origFetch = (typeof window!=='undefined' && window.fetch) ? window.fetch.bind(window) : null;
          if (origFetch && !window.__MLIP_FETCH_LATENCY_WRAPPED__) {
            window.__MLIP_FETCH_LATENCY_WRAPPED__ = true;
            window.fetch = async function(input, init){
              const method = (init && init.method) || (input && input.method) || 'GET';
              const url = (typeof input === 'string') ? input : (input && (input.url || input.toString())) || 'unknown';
              const t0 = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
              try {
                const resp = await origFetch(input, init);
                const t1 = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
                const ms = Math.round((t1 - t0)*100)/100;
                const status = (resp && typeof resp.status==='number') ? resp.status : 'n/a';
                console.log(`[latency] ${method} ${url} -> ${status} in ${ms} ms`);
                return resp;
              } catch (err) {
                const t1 = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
                const ms = Math.round((t1 - t0)*100)/100;
                const msg = (err && (err.message||String(err))) || 'error';
                console.warn(`[latency] ${method} ${url} -> network error in ${ms} ms: ${msg}`);
                throw err;
              }
            };
            try { console.log('[latency] fetch timing enabled'); } catch{}
          }
        }
      } catch {}
    })();
  </script>
</head>
<body>
  <div id="app">
    <canvas id="viewer"></canvas>
    <!-- Minimal status placeholder to satisfy smoke tests before panel builds -->
    <span id="status" style="position:absolute;left:-9999px;top:-9999px;">Ready</span>
    <div class="footer">FAIRChem UMA viewer</div>
  </div>
  <script type="module">
    import { initNewViewer } from './index.js';
    import { loadDefault } from './util/moleculeLoader.js';
    import { buildDesktopPanel } from './ui/desktopPanel.js';
    import { initForcesToggle } from './ui/forcesToggle.js';
    import { initCellToggle } from './ui/cellToggle.js';
    const urlParams = new URLSearchParams(location.search);
    const DEBUG = urlParams.get('debug') === '1';
    const canvas=document.getElementById('viewer');
    let viewerApi;
    // Desktop initialization (runs immediately; we keep always-on desktop mode and allow VR overlay switch)
    (async()=>{
      // Start with empty molecule; loader will populate.
      viewerApi = await initNewViewer(canvas,{ elements:[], positions:[], bonds:[] });
      // Always expose viewer globally for VR reuse (was previously behind DEBUG flag)
      window._viewer = viewerApi;
      try {
        window.viewerApi = viewerApi;
        window.dispatchEvent(new CustomEvent('mlipviewer-ready',{ detail:{ when: Date.now() }}));
      } catch {}
      window.vrScene = viewerApi.scene; // redundancy for VR module
      window.vrEngine = viewerApi.engine;
      if (DEBUG) console.log('[debug] viewer initialized');
  // Build left-side control panel (collapsible sections)
  buildDesktopPanel({ attachTo: document.getElementById('app') });

  // (Bond rotation controls now live in the Selection panel)
      try {
  const { file } = await loadDefault(viewerApi);
  // Reset energy series to a single initial point (avoid multiple startup entries)
  try { viewerApi.baselineEnergy?.(); } catch {}
  document.getElementById('status').textContent = `Loaded ${file}`;
  try { const sel = document.getElementById('moleculeSelect'); if (sel) sel.value = file; } catch{}
  if (DEBUG) console.log('[debug] default molecule loaded', file, 'atoms=', viewerApi.state.positions.length, 'energySeriesLen=1');
        window.__MLIP_DEFAULT_LOADED = true;
      } catch (e) {
        document.getElementById('status').textContent = 'Load failed';
        console.error(e);
        window.__MLIP_DEFAULT_LOADED = true; // still allow tests to proceed
      }
    })();
  // Relax controls (step / run-toggle)
  const relaxStepBtn = document.getElementById('btnRelax');
  const relaxRunBtn = document.getElementById('btnRelaxRun');
  function isRelaxRunning(){ try { return !!(viewerApi && viewerApi.getMetrics().running === 'relax'); } catch { return false; } }
  function applyRunningDisable(){
    const runningKind = viewerApi && viewerApi.getMetrics().running;
    const disabled = !!runningKind;
    // Disable all four when anything running
    // But only keep the active run button enabled (for stopping) when running
    relaxStepBtn.disabled = disabled;
    mdStepBtn.disabled = disabled;
    relaxRunBtn.disabled = false; // toggling logic inside
    mdRunBtn.disabled = false;
    if(runningKind === 'relax'){
      mdRunBtn.disabled = true; mdStepBtn.disabled = true;
    } else if(runningKind === 'md') {
      relaxRunBtn.disabled = true; relaxStepBtn.disabled = true;
    }
  }
  relaxStepBtn.onclick = async ()=>{ if(!viewerApi || isRelaxRunning() || isMdRunning()) return; await viewerApi.relaxStep(); document.getElementById('status').textContent='Relax step'; };
  relaxRunBtn.onclick = async ()=>{
    if(!viewerApi) return;
    if(!isRelaxRunning()){
      relaxRunBtn.textContent='stop'; document.getElementById('status').textContent='Relax running';
      applyRunningDisable();
      viewerApi.startRelaxContinuous({ maxSteps:500 }).then(r=>{ relaxRunBtn.textContent='run'; applyRunningDisable(); document.getElementById('status').textContent = r?.converged? 'Relax converged':'Relax stopped'; });
    } else {
      viewerApi.stopSimulation(); relaxRunBtn.textContent='run'; applyRunningDisable(); document.getElementById('status').textContent='Relax stopped';
    }
  };
  // MD controls (step / run-toggle)
  const mdStepBtn = document.getElementById('btnMD');
  const mdRunBtn = document.getElementById('btnMDRun');
  // Derive MD running state from viewerApi.getMetrics() so auto-start logic stays in sync.
  function isMdRunning(){ try { return !!(viewerApi && viewerApi.getMetrics().running === 'md'); } catch { return false; } }
  mdStepBtn.onclick = ()=>{ if(!viewerApi || isMdRunning() || isRelaxRunning()) return; const T = window.__MLIP_TARGET_TEMPERATURE ?? 1500; viewerApi.mdStep({ temperature:T }); document.getElementById('status').textContent=`MD step tgt=${T}K inst=${viewerApi.state.dynamics.temperature.toFixed(1)}`; };
  mdRunBtn.onclick = ()=>{
    if(!viewerApi) return;
    if(!isMdRunning()){
  const T = window.__MLIP_TARGET_TEMPERATURE ?? 1500;
      mdRunBtn.textContent='stop'; document.getElementById('status').textContent='MD running @'+T+'K';
      applyRunningDisable();
      viewerApi.startMDContinuous({ steps:500, temperature:T }).then(()=>{ if(!isMdRunning()) { mdRunBtn.textContent='run'; applyRunningDisable(); document.getElementById('status').textContent='MD stopped'; } });
    } else {
      viewerApi.stopSimulation(); mdRunBtn.textContent='run'; applyRunningDisable(); document.getElementById('status').textContent='MD stopped';
    }
  };
  document.getElementById('forceProviderSel').onchange = (e)=>{ if(!viewerApi) return; const kind=e.target.value; viewerApi.setForceProvider(kind); document.getElementById('status').textContent='Provider '+kind; };

  // Periodic metrics HUD updater
  setInterval(()=>{ if(!viewerApi) return; const m=viewerApi.getMetrics(); applyRunningDisable(); if(!m.running) return; const parts=[]; if(m.energy!=null) parts.push('E='+m.energy.toFixed(3)); if(m.maxForce!=null) parts.push('Fmax='+m.maxForce.toExponential(2)); if(m.maxStress!=null) parts.push('Smax='+m.maxStress.toExponential(2)); document.getElementById('status').textContent = (m.running||'idle')+' '+parts.join(' '); }, 500);
  // Unified Cell toggle controls both cell and ghost states
  initCellToggle({ getViewer: ()=> viewerApi });
  // Forces toggle wiring (button text and state)
  initForcesToggle({ getViewer: ()=> viewerApi });

    // XR dropdown wiring (now static in markup for reliability)
  const xrSel = document.getElementById('xrModeSelect');
    xrSel.addEventListener('change', async ()=> {
      if(!viewerApi) return;
      const v = xrSel.value;
      if(v==='none'){ await viewerApi.vr.switchXR('none'); }
      else if(v==='vr'){ await viewerApi.vr.switchXR('vr'); }
      else if(v==='ar'){ await viewerApi.vr.switchXR('ar'); }
    });
    setInterval(()=>{
      if(!viewerApi) return;
      try {
        const info=viewerApi.vr.debugInfo();
        let mode='none';
        if(info.sessionMode.includes('ar')) mode='ar';
        else if(info.sessionMode.includes('vr')||info.hasXRHelper && info.sessionMode!=='unknown') mode='vr';
        if(xrSel.value!==mode) xrSel.value=mode;
      } catch{}
    }, 2000);
  </script>
</body>
</html>
