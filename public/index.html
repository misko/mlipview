<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>MLIP Viewer 2</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
  html,body { margin:0; padding:0; height:100%; background:#ffffff; font-family: system-ui, sans-serif; color:#222; }
    #app { position:relative; width:100%; height:100%; overflow:hidden; }
    canvas { width:100%; height:100%; display:block; }
    .hud { position:absolute; top:8px; left:8px; background:rgba(20,26,34,0.65); border:1px solid rgba(255,255,255,0.07); border-radius:8px; padding:8px 12px; font-size:13px; backdrop-filter: blur(4px); }
    .hud button { margin-right:6px; }
    .footer { position:absolute; bottom:8px; left:8px; font-size:11px; opacity:0.6; }
    a { color:#7fc4ff; }
    /* Removed standalone VR/AR buttons; unified AR transparency toggle lives in HUD */
    .hud .inline-toggle { display:inline-flex; align-items:center; gap:4px; margin-left:4px; }
  </style>
  <!-- Load Babylon globally so legacy-style modules that reference global BABYLON work -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <!-- Loaders plugin for glTF/glb (controllers, hand meshes) -->
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
  <!-- Babylon GUI for XR HUD overlay -->
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script>
    // Predeclare global so console commands entered early don't throw ReferenceError
    (function(){ try { if(typeof window!=='undefined' && !('viewerApi' in window)) window.viewerApi = null; } catch{} })();
  </script>
  <script>
    // Optional latency debug: enable with ?debugLatency=1 to log round-trip times of all fetch() calls
    (function(){
      try {
        const params = new URLSearchParams(location.search||'');
        if (params.get('debugLatency') === '1') {
          const origFetch = (typeof window!=='undefined' && window.fetch) ? window.fetch.bind(window) : null;
          if (origFetch && !window.__MLIP_FETCH_LATENCY_WRAPPED__) {
            window.__MLIP_FETCH_LATENCY_WRAPPED__ = true;
            window.fetch = async function(input, init){
              const method = (init && init.method) || (input && input.method) || 'GET';
              const url = (typeof input === 'string') ? input : (input && (input.url || input.toString())) || 'unknown';
              const t0 = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
              try {
                const resp = await origFetch(input, init);
                const t1 = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
                const ms = Math.round((t1 - t0)*100)/100;
                const status = (resp && typeof resp.status==='number') ? resp.status : 'n/a';
                console.log(`[latency] ${method} ${url} -> ${status} in ${ms} ms`);
                return resp;
              } catch (err) {
                const t1 = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
                const ms = Math.round((t1 - t0)*100)/100;
                const msg = (err && (err.message||String(err))) || 'error';
                console.warn(`[latency] ${method} ${url} -> network error in ${ms} ms: ${msg}`);
                throw err;
              }
            };
            try { console.log('[latency] fetch timing enabled'); } catch{}
          }
        }
      } catch {}
    })();
  </script>
</head>
<body>
  <div id="app">
    <canvas id="viewer"></canvas>
  <div class="hud">
  <span style="margin-right:4px;">Relax:</span>
  <button id="btnRelax" title="Single relaxation step">step</button>
  <button id="btnRelaxRun" title="Continuous relaxation run">run</button>
  <span style="margin-left:10px;margin-right:4px;">MD:</span>
  <button id="btnMD" title="Single MD step">step</button>
  <button id="btnMDRun" title="Continuous MD run">run</button>
  <select id="forceProviderSel"><option value="fairchem">UMA (Remote)</option></select>
  <button id="btnCell">Cell</button>
  <button id="btnGhosts">Ghosts</button>
  <button id="btnToggleForces" title="Toggle force vectors (normalized)">Forces</button>
      <span id="status">Ready</span>
    <span id="instTemp" style="margin-left:6px;">T: --.- K</span>
    <span id="rpsLabel" style="margin-left:6px;">RPS: --</span>
      <select id="xrModeSelect" style="margin-left:6px" title="Switch XR mode">
        <option value="none">SelectVR</option>
        <option value="vr">VR</option>
        <option value="ar">AR</option>
      </select>
      <div id="energyPlot" style="margin-top:6px;width:260px;height:80px;background:rgba(255,255,255,0.05);position:relative;overflow:hidden;border:1px solid rgba(255,255,255,0.08);border-radius:4px;">
        <canvas id="energyCanvas" width="260" height="80" style="position:absolute;left:0;top:0;"></canvas>
        <div id="energyLabel" style="position:absolute;left:4px;top:2px;font-size:10px;opacity:0.8;">E plot</div>
      </div>
      <div id="bond-rotation-ui" style="position:absolute;top:10px;right:10px;display:none;z-index:10;font-family:Arial;">
        <button id="bond-rot-minus" style="margin:2px;">-</button>
        <button id="bond-rot-plus" style="margin:2px;">+</button>
      </div>
    </div>
    <div class="footer">MLIP Viewer 2 â€“ separate project</div>
  </div>
  <script type="module">
    import { initNewViewer } from './index.js';
    import { loadDefault, loadXYZIntoViewer } from './util/moleculeLoader.js';
  import { initTemperatureSlider } from './ui/temperatureSlider.js';
  import { initForcesToggle } from './ui/forcesToggle.js';
    const urlParams = new URLSearchParams(location.search);
    const DEBUG = urlParams.get('debug') === '1';
    const canvas=document.getElementById('viewer');
    let viewerApi;
    // Desktop initialization (runs immediately; we keep always-on desktop mode and allow VR overlay switch)
    (async()=>{
      // Start with empty molecule; loader will populate.
      viewerApi = await initNewViewer(canvas,{ elements:[], positions:[], bonds:[] });
      // Always expose viewer globally for VR reuse (was previously behind DEBUG flag)
      window._viewer = viewerApi;
      try {
        window.viewerApi = viewerApi;
        window.dispatchEvent(new CustomEvent('mlipviewer-ready',{ detail:{ when: Date.now() }}));
      } catch {}
      window.vrScene = viewerApi.scene; // redundancy for VR module
      window.vrEngine = viewerApi.engine;
      if (DEBUG) console.log('[debug] viewer initialized');
      // Bond rotation UI wiring
      const rotUI = document.getElementById('bond-rotation-ui');
      const rotMinus = document.getElementById('bond-rot-minus');
      const rotPlus = document.getElementById('bond-rot-plus');
      const EPS = 0.1; // radians per click
      function refreshRotationUI() {
        const sel = viewerApi.selection.get();
        if (sel.kind === 'bond') rotUI.style.display = 'block'; else rotUI.style.display = 'none';
      }
      viewerApi.state.bus.on('selectionChanged', refreshRotationUI);
      rotMinus.addEventListener('click', ()=>{ viewerApi.manipulation.rotateBond(-EPS); });
      rotPlus.addEventListener('click', ()=>{ viewerApi.manipulation.rotateBond(EPS); });
      try {
  const { file } = await loadDefault(viewerApi);
  // Reset energy series to a single initial point (avoid multiple startup entries)
  try { viewerApi.baselineEnergy?.(); } catch {}
  document.getElementById('status').textContent = `Loaded ${file}`;
  if (DEBUG) console.log('[debug] default molecule loaded', file, 'atoms=', viewerApi.state.positions.length, 'energySeriesLen=1');
        window.__MLIP_DEFAULT_LOADED = true;
      } catch (e) {
        document.getElementById('status').textContent = 'Load failed';
        console.error(e);
        window.__MLIP_DEFAULT_LOADED = true; // still allow tests to proceed
      }
    })();
  // Relax controls (step / run-toggle)
  const relaxStepBtn = document.getElementById('btnRelax');
  const relaxRunBtn = document.getElementById('btnRelaxRun');
  function isRelaxRunning(){ try { return !!(viewerApi && viewerApi.getMetrics().running === 'relax'); } catch { return false; } }
  function applyRunningDisable(){
    const runningKind = viewerApi && viewerApi.getMetrics().running;
    const disabled = !!runningKind;
    // Disable all four when anything running
    // But only keep the active run button enabled (for stopping) when running
    relaxStepBtn.disabled = disabled;
    mdStepBtn.disabled = disabled;
    relaxRunBtn.disabled = false; // toggling logic inside
    mdRunBtn.disabled = false;
    if(runningKind === 'relax'){
      mdRunBtn.disabled = true; mdStepBtn.disabled = true;
    } else if(runningKind === 'md') {
      relaxRunBtn.disabled = true; relaxStepBtn.disabled = true;
    }
  }
  relaxStepBtn.onclick = async ()=>{ if(!viewerApi || isRelaxRunning() || isMdRunning()) return; await viewerApi.relaxStep(); document.getElementById('status').textContent='Relax step'; };
  relaxRunBtn.onclick = async ()=>{
    if(!viewerApi) return;
    if(!isRelaxRunning()){
      relaxRunBtn.textContent='stop'; document.getElementById('status').textContent='Relax running';
      applyRunningDisable();
      viewerApi.startRelaxContinuous({ maxSteps:500 }).then(r=>{ relaxRunBtn.textContent='run'; applyRunningDisable(); document.getElementById('status').textContent = r?.converged? 'Relax converged':'Relax stopped'; });
    } else {
      viewerApi.stopSimulation(); relaxRunBtn.textContent='run'; applyRunningDisable(); document.getElementById('status').textContent='Relax stopped';
    }
  };
  // MD controls (step / run-toggle)
  const mdStepBtn = document.getElementById('btnMD');
  const mdRunBtn = document.getElementById('btnMDRun');
  // Derive MD running state from viewerApi.getMetrics() so auto-start logic stays in sync.
  function isMdRunning(){ try { return !!(viewerApi && viewerApi.getMetrics().running === 'md'); } catch { return false; } }
  mdStepBtn.onclick = ()=>{ if(!viewerApi || isMdRunning() || isRelaxRunning()) return; const T = window.__MLIP_TARGET_TEMPERATURE ?? 298; viewerApi.mdStep({ temperature:T }); document.getElementById('status').textContent=`MD step tgt=${T}K inst=${viewerApi.state.dynamics.temperature.toFixed(1)}`; };
  mdRunBtn.onclick = ()=>{
    if(!viewerApi) return;
    if(!isMdRunning()){
      const T = window.__MLIP_TARGET_TEMPERATURE ?? 298;
      mdRunBtn.textContent='stop'; document.getElementById('status').textContent='MD running @'+T+'K';
      applyRunningDisable();
      viewerApi.startMDContinuous({ steps:500, temperature:T }).then(()=>{ if(!isMdRunning()) { mdRunBtn.textContent='run'; applyRunningDisable(); document.getElementById('status').textContent='MD stopped'; } });
    } else {
      viewerApi.stopSimulation(); mdRunBtn.textContent='run'; applyRunningDisable(); document.getElementById('status').textContent='MD stopped';
    }
  };
  document.getElementById('forceProviderSel').onchange = (e)=>{ if(!viewerApi) return; const kind=e.target.value; viewerApi.setForceProvider(kind); document.getElementById('status').textContent='Provider '+kind; };

  // Periodic metrics HUD updater
  setInterval(()=>{ if(!viewerApi) return; const m=viewerApi.getMetrics(); applyRunningDisable(); if(!m.running) return; const parts=[]; if(m.energy!=null) parts.push('E='+m.energy.toFixed(3)); if(m.maxForce!=null) parts.push('Fmax='+m.maxForce.toExponential(2)); if(m.maxStress!=null) parts.push('Smax='+m.maxStress.toExponential(2)); document.getElementById('status').textContent = (m.running||'idle')+' '+parts.join(' '); }, 500);
  document.getElementById('btnCell').onclick=()=>{ if(!viewerApi) return; (viewerApi.state.toggleCellVisibilityEnhanced||viewerApi.state.toggleCellVisibility).call(viewerApi.state); document.getElementById('status').textContent = viewerApi.state.showCell? 'Cell ON':'Cell OFF'; };
  document.getElementById('btnGhosts').onclick=()=>{ if(!viewerApi) return; viewerApi.state.toggleGhostCells(); document.getElementById('status').textContent = viewerApi.state.showGhostCells? 'Ghosts ON':'Ghosts OFF'; };
  // Forces toggle wiring (button text and state)
  initForcesToggle({ getViewer: ()=> viewerApi });
    // Simple molecule switch UI (development convenience)
  const switcher = document.createElement('select');
  switcher.id = 'moleculeSelect'; // stable id for tests
  switcher.innerHTML = '<option value="molecules/roy.xyz">ROY</option><option value="molecules/benzene.xyz">Benzene</option><option value="molecules/water.xyz">Water</option>';
    switcher.onchange = async () => {
      if (!viewerApi) return;
      const file = switcher.value;
      document.getElementById('status').textContent = `Loading ${file}...`;
      try {
  await loadXYZIntoViewer(viewerApi, file);
  try { viewerApi.baselineEnergy?.(); } catch {}
  document.getElementById('status').textContent = `Loaded ${file} (baseline reset)`;
  if (DEBUG) console.log('[debug] switched molecule', file, 'atoms=', viewerApi.state.positions.length, 'baseline reset');
      } catch (e) {
        document.getElementById('status').textContent = `Failed ${file}`;
      }
    };
  const hudEl = document.querySelector('.hud');
  hudEl.appendChild(switcher);
  // Initialize temperature slider (after HUD present; viewerApi may not yet be ready so pass getter)
  initTemperatureSlider({ hudEl, getViewer: ()=> viewerApi });

    // XR dropdown wiring (now static in markup for reliability)
    const xrSel = document.getElementById('xrModeSelect');
    xrSel.addEventListener('change', async ()=> {
      if(!viewerApi) return;
      const v = xrSel.value;
      if(v==='none'){ await viewerApi.vr.switchXR('none'); }
      else if(v==='vr'){ await viewerApi.vr.switchXR('vr'); }
      else if(v==='ar'){ await viewerApi.vr.switchXR('ar'); }
    });
    setInterval(()=>{
      if(!viewerApi) return;
      try {
        const info=viewerApi.vr.debugInfo();
        let mode='none';
        if(info.sessionMode.includes('ar')) mode='ar';
        else if(info.sessionMode.includes('vr')||info.hasXRHelper && info.sessionMode!=='unknown') mode='vr';
        if(xrSel.value!==mode) xrSel.value=mode;
      } catch{}
    }, 2000);
  </script>
</body>
</html>
